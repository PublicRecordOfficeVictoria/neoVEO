/*
 * Copyright Public Record Office Victoria 2015
 * Licensed under the CC-BY license http://creativecommons.org/licenses/by/3.0/au/
 * Author Andrew Waugh
 * Version 1.0 February 2015
 */
package VEOAnalysis;

import VERSCommon.LTSF;
import VERSCommon.ResultSummary;
import VERSCommon.VEOError;
import VERSCommon.VEOFailure;
import java.io.Writer;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

/**
 * This class encapsulates an Information Piece in a VEO Content file.
 *
 * @author Andrew Waugh
 */
class RepnInformationPiece extends Repn {
    private static String classname = "RepnInformatioPiece";
    private RepnItem label;  // label of the piece
    private ArrayList<RepnContentFile> contents;  // list of metadata packages

    /**
     * Construct an Information Object from the XML document VEOContent.xml.
     *
     * @param document the representation of the XML document
     * @param parentId the parent object identifier
     * @param seq the sequence number of this IP within the Information Object
     * @param results the results summary to build
     * @throws VEOError if the XML document has not been properly parsed
     */
    public RepnInformationPiece(RepnXML document, String parentId, int seq, ResultSummary results) {
        super(parentId + ":IP-" + seq, results);

        int i;
        
        assert(document != null);
        assert(parentId != null);
        
        contents = new ArrayList<>();
        
        // vers:Label
        if (document.checkElement("vers:Label")) {
            label = new RepnItem(id, "Information piece label", results);
            label.setValue(document.getTextValue());
            document.gotoNextElement();
        } else {
            label = null;
        }

        i = 0;
        while (!document.atEnd() && document.checkElement("vers:ContentFile")) {
            document.gotoNextElement();
            i++;
            contents.add(new RepnContentFile(document, id, i, results));
        }
        objectValid = true;
    }

    /**
     * Free resources associated with this object
     */
    @Override
    public void abandon() {
        int i;

        super.abandon();
        if (label != null) {
            label.abandon();
            label = null;
        }
        for (i = 0; i < contents.size(); i++) {
            contents.get(i).abandon();
        }
        contents.clear();
        contents = null;
    }

    /**
     * Validate the data in the Information Piece.
     *
     * @param veoDir the directory containing the contents of the VEO
     * @param hashAlgorithm the hash algorithm used to check integrity of the
     * @param contentFiles the collection of content files in the VEO files
     * @param ltsfs List of valid long term sustainable formats
     * @param vpa true if being called from VPA & don't check for LTSF
     * @throws VEOError if an error occurred that won't preclude processing
     * another VEO
     */
    public void validate(Path veoDir, String hashAlgorithm, HashMap<Path, RepnFile> contentFiles, LTSF ltsfs, boolean vpa) {
        int i;
        RepnContentFile rcf;
        boolean validLTPF;
        
        assert(veoDir != null);
        assert(hashAlgorithm != null);
        assert(contentFiles != null);
        assert(ltsfs != null);

        // validate Content Files within Information Piece        
        for (i = 0; i < contents.size(); i++) {
            rcf = contents.get(i);
            rcf.validate(veoDir, hashAlgorithm, contentFiles, ltsfs);
        }

        // must have at least one valid long term preservation format
        // do not perform this check if being called from VPA
        if (!vpa) {
            validLTPF = false;
            for (i = 0; i < contents.size(); i++) {
                rcf = contents.get(i);
                validLTPF |= rcf.isLTPF();
            }
            if (!validLTPF) {
                addError(new VEOFailure(classname, "validate", 1, id, "Information piece did not have a valid long term preservation format"));
            }
        }
    }

    /**
     * Check if this object has any errors?
     *
     * @return true if errors have been detected
     */
    @Override
    public boolean hasErrors() {
        int i;

        for (i = 0; i < contents.size(); i++) {
            hasErrors |= contents.get(i).hasErrors();
        }
        return hasErrors;
    }

    /**
     * Build a list of all of the errors generated by this RepnInformationPiece
     * 
     * @param returnErrors if true return errors, otherwise return warnings
     * @param l list in which to place the errors/warnings
     */
    @Override
    public void getProblems(boolean returnErrors, List<VEOFailure> l) {
        int i;
        
        assert(l != null);

        super.getProblems(returnErrors, l);
        for (i = 0; i < contents.size(); i++) {
            contents.get(i).getProblems(returnErrors, l);
        }
    }

    /**
     * Has this object (or its children) any warnings?
     *
     * @return true if errors have been detected
     */
    @Override
    public boolean hasWarnings() {
        int i;

        for (i = 0; i < contents.size(); i++) {
            hasWarnings |= contents.get(i).hasWarnings();
        }
        return hasWarnings;
    }

    /**
     * Produce a string representation of the Information Piece
     *
     * @return The string representation
     */
    @Override
    public String toString() {
        StringBuffer sb;
        int i;

        sb = new StringBuffer();
        sb.append("   Information Piece (Label:");
        if (label != null) {
            sb.append(label);
        } else {
            sb.append("<no label>");
        }
        sb.append(")\n");
        for (i = 0; i < contents.size(); i++) {
            sb.append(contents.get(i).toString());
        }
        return sb.toString();
    }

    /**
     * Generate an XML representation of the information piece
     *
     * @param verbose true if additional information is to be generated
     * @param writer where to write the output
     * @throws VERSCommon.VEOError if prevented from continuing processing this
     * VEO
     */
    public void genReport(boolean verbose, Writer w) {
        int i;

        assert(w != null);
        
        this.w = w;
        startDiv("InfoPiece", null);
        addLabel("Information Piece");
        if (label != null) {
            addString(" (Label: " + label.getValue() + ")");
        } else {
            addString(" <no label>");
        }
        addString("\n");
        if (hasErrors || hasWarnings) {
            addTag("<ul>\n");
            listIssues();
            addTag("</ul>\n");
        }
        for (i = 0; i < contents.size(); i++) {
            contents.get(i).genReport(verbose, w);
        }
        endDiv();
    }
}
