/*
 * Copyright Public Record Office Victoria 2015
 * Licensed under the CC-BY license http://creativecommons.org/licenses/by/3.0/au/
 * Author Andrew Waugh
 * Version 1.0 February 2015
 */
package VEOAnalysis;

import VERSCommon.VERSDate;
import VERSCommon.VEOError;
import java.io.BufferedWriter;
import java.util.ArrayList;

/**
 * This class encapsulates an event in the history of a VEO. An event consists
 * of a date and time, an event type, an initiator of the event, an array of
 * textual descriptions of the event, and an array of errors that occurred
 * during the event.
 */
class RepnEvent extends Repn {

    private RepnItem dateTime;   // date and time of the event
    private RepnItem eventType;  // event type
    private RepnItem initiator;  // initiator of the event
    private ArrayList<RepnItem> descriptions;  // descriptions of the event
    private ArrayList<RepnItem> errorDescs; // errors that occurred in the event
    
    /**
     * Construct an Event from the XML document VEOHistory.xml.
     *
     * @param document the representation of the XML document
     * @param parentId the parent object identifier
     * @param seq sequence no of event in history file
     * @throws VEOError if the XML document has not been properly parsed
     */
    public RepnEvent(RepnXML document, String parentId, int seq) throws VEOError {
        super(parentId + ":E-" + seq);

        RepnItem ri;

        // vers:EventDateTime
        dateTime = new RepnItem(getId(), "Event date & time");
        dateTime.setValue(document.getTextValue());
        document.gotoNextElement();

        // vers:EventType
        eventType = new RepnItem(getId(), "Event type");
        eventType.setValue(document.getTextValue());
        document.gotoNextElement();

        // vers:Initiator
        initiator = new RepnItem(getId(), "Event initiator");
        initiator.setValue(document.getTextValue());
        document.gotoNextElement();

        descriptions = new ArrayList<>();
        while (document.checkElement("vers:Description")) {
            ri = new RepnItem(getId(), "Event description");
            ri.setValue(document.getTextValue());
            descriptions.add(ri);
            document.gotoNextElement();
        }
        errorDescs = new ArrayList<>();
        while (document.checkElement("vers:Error")) {
            ri = new RepnItem(getId(), "Event error");
            ri.setValue(document.getTextValue());
            errorDescs.add(ri);
            document.gotoNextElement();
        }
    }

    /**
     * Free resources in this Event.
     */
    @Override
    public void abandon() {
        int i;

        super.abandon();
        dateTime.abandon();
        dateTime = null;
        eventType.abandon();
        eventType = null;
        initiator.abandon();
        initiator = null;
        for (i = 0; i < descriptions.size(); i++) {
            descriptions.get(i).abandon();
        }
        descriptions.clear();
        descriptions = null;
        for (i = 0; i < errorDescs.size(); i++) {
            errorDescs.get(i).abandon();
        }
        errorDescs.clear();
        errorDescs = null;

    }

    /**
     * Validate the data in the Event.
     *
     * @throws VEOError if an error occurred that won't preclude processing
     * another VEO
     */
    public void validate() throws VEOError {
        try {
            VERSDate.testValueAsDate(dateTime.getValue());
        } catch (IllegalArgumentException e) {
            dateTime.addError("Date in event is invalid: "+e.getMessage());
            hasErrors = true;
        }
    }

    /**
     * Check if this Event has any errors?
     *
     * @return true if errors have been detected
     */
    @Override
    public boolean hasErrors() {
        int i;

        hasErrors |= dateTime.hasErrors() | eventType.hasErrors() | initiator.hasErrors();
        for (i = 0; i < descriptions.size(); i++) {
            hasErrors |= descriptions.get(i).hasErrors();
        }
        for (i = 0; i < errorDescs.size(); i++) {
            hasErrors |= errorDescs.get(i).hasErrors();
        }
        return hasErrors;
    }

    /**
     * Build a list of all of the errors generated by this Event
     * @return String containing the concatenated error list
     */
    @Override
    public String getErrors() {
        StringBuffer sb;
        int i;

        sb = new StringBuffer();
        sb.append(super.getErrors());
        sb.append(dateTime.getErrors());
        sb.append(eventType.getErrors());
        sb.append(initiator.getErrors());
        for (i = 0; i < descriptions.size(); i++) {
            sb.append(descriptions.get(i).getErrors());
        }
        for (i = 0; i < errorDescs.size(); i++) {
            sb.append(errorDescs.get(i).getErrors());
        }
        return sb.toString();
    }

    /**
     * Has this Event any warnings?
     * @return true if errors have been detected
     */
    @Override
    public boolean hasWarnings() {
        int i;

        hasWarnings |= dateTime.hasWarnings() | eventType.hasWarnings() | initiator.hasWarnings();
        for (i = 0; i < descriptions.size(); i++) {
            hasWarnings |= descriptions.get(i).hasWarnings();
        }
        for (i = 0; i < errorDescs.size(); i++) {
            hasWarnings |= errorDescs.get(i).hasWarnings();
        }
        return hasWarnings;
    }

    /**
     * Build a list of all of the warnings generated by this Event
     * @return String containing the concatenated error list
     */
    @Override
    public String getWarnings() {
        StringBuffer sb;
        int i;

        sb = new StringBuffer();
        sb.append(super.getWarnings());
        sb.append(dateTime.getWarnings());
        sb.append(eventType.getWarnings());
        sb.append(initiator.getWarnings());
        for (i = 0; i < descriptions.size(); i++) {
            sb.append(descriptions.get(i).getWarnings());
        }
        for (i = 0; i < errorDescs.size(); i++) {
            sb.append(errorDescs.get(i).getWarnings());
        }
        return sb.toString();
    }

    /**
     * Produce a string representation of the Event
     *
     * @return The string representation
     */
    @Override
    public String toString() {
        StringBuffer sb;
        int i;

        sb = new StringBuffer();
        sb.append("Event\n   Date:");
        sb.append(dateTime);
        sb.append(" Event:");
        sb.append(eventType);
        sb.append(" Initiator:");
        sb.append(initiator);
        sb.append("\n");
        for (i = 0; i < descriptions.size(); i++) {
            sb.append("   Description:");
            sb.append(descriptions.get(i).toString());
            sb.append("\n");
        }
        for (i = 0; i < errorDescs.size(); i++) {
            sb.append("   Error:");
            sb.append(errorDescs.get(i).toString());
            sb.append("\n");
        }
        return sb.toString();
    }

    /**
     * Generate a HTML representation of the Event
     * @param verbose true if additional information is to be generated
     * @throws VERSCommon.VEOError if prevented from continuing processing this VEO
     */
    public void genReport(boolean verbose) throws VEOError {
        int i;

        startDiv("Event", null);
        addLabel(eventType.getValue()+"Event");
        if (hasErrors || hasWarnings) {
            addTag("<ul>\n");
            listIssues();
            addTag("</ul>\n");
        }
        dateTime.genReport(verbose);
        initiator.genReport(verbose);
        for (i = 0; i < descriptions.size(); i++) {
            descriptions.get(i).genReport(verbose);
        }
        for (i = 0; i < errorDescs.size(); i++) {
            errorDescs.get(i).genReport(verbose);
        }
        endDiv();
    }

    /**
     * Tell all the Representations where to write the HTML
     *
     * @param bw buffered writer for output
     */
    @Override
    public void setReportWriter(BufferedWriter bw) {
        int i;

        super.setReportWriter(bw);
        dateTime.setReportWriter(bw);
        eventType.setReportWriter(bw);
        initiator.setReportWriter(bw);
        for (i = 0; i < descriptions.size(); i++) {
            descriptions.get(i).setReportWriter(bw);
        }
        for (i = 0; i < errorDescs.size(); i++) {
            errorDescs.get(i).setReportWriter(bw);
        }
    }
}
