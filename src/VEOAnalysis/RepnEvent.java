/*
 * Copyright Public Record Office Victoria 2015
 * Licensed under the CC-BY license http://creativecommons.org/licenses/by/3.0/au/
 * Author Andrew Waugh
 * Version 1.0 February 2015
 */
package VEOAnalysis;

import VERSCommon.ResultSummary;
import VERSCommon.VERSDate;
import VERSCommon.VEOFailure;
import java.io.Writer;
import java.util.ArrayList;
import java.util.List;

/**
 * This class encapsulates an event in the history of a VEO. An event consists
 * of a date and time, an event type, an initiator of the event, an array of
 * textual descriptions of the event, and an array of errors that occurred
 * during the event.
 */
class RepnEvent extends Repn {
    private static final String CLASSNAME = "RepnEvent";
    private RepnItem dateTime;   // date and time of the event
    private RepnItem eventType;  // event type
    private RepnItem initiator;  // initiator of the event
    private ArrayList<RepnItem> descriptions;  // descriptions of the event
    private ArrayList<RepnItem> errorDescs; // errors that occurred in the event
    
    /**
     * Construct an Event from the XML document VEOHistory.xml.
     *
     * @param document the representation of the XML document
     * @param parentId the parent object identifier
     * @param seq sequence no of event in history file
     * @param results the results summary to build
     */
    public RepnEvent(RepnXML document, String parentId, int seq, ResultSummary results) {
        super(parentId + ":E-" + seq, results);

        RepnItem ri;
        
        assert(document != null);
        
        descriptions = new ArrayList<>();
        errorDescs = new ArrayList<>();

        // vers:EventDateTime
        dateTime = new RepnItem(getId(), "Event date & time", results);
        dateTime.setValue(document.getTextValue());
        document.gotoNextElement();

        // vers:EventType
        eventType = new RepnItem(getId(), "Event type", results);
        eventType.setValue(document.getTextValue());
        document.gotoNextElement();

        // vers:Initiator
        initiator = new RepnItem(getId(), "Event initiator", results);
        initiator.setValue(document.getTextValue());
        document.gotoNextElement();

        while (document.checkElement("vers:Description")) {
            ri = new RepnItem(getId(), "Event description", results);
            ri.setValue(document.getTextValue());
            descriptions.add(ri);
            document.gotoNextElement();
        }
        while (document.checkElement("vers:Error")) {
            ri = new RepnItem(getId(), "Event error", results);
            ri.setValue(document.getTextValue());
            errorDescs.add(ri);
            document.gotoNextElement();
        }
        objectValid = true;
    }

    /**
     * Free resources in this Event.
     */
    @Override
    public void abandon() {
        int i;

        super.abandon();
        dateTime.abandon();
        dateTime = null;
        eventType.abandon();
        eventType = null;
        initiator.abandon();
        initiator = null;
        for (i = 0; i < descriptions.size(); i++) {
            descriptions.get(i).abandon();
        }
        descriptions.clear();
        descriptions = null;
        for (i = 0; i < errorDescs.size(); i++) {
            errorDescs.get(i).abandon();
        }
        errorDescs.clear();
        errorDescs = null;

    }

    /**
     * Validate the data in the Event.
     */
    public void validate() {
        try {
            VERSDate.testValueAsDate(dateTime.getValue());
        } catch (IllegalArgumentException e) {
            dateTime.addError(new VEOFailure(CLASSNAME, "validate", 1, "Date in event is invalid", e));
            hasErrors = true;
        }
    }

    /**
     * Check if this Event has any errors?
     *
     * @return true if errors have been detected
     */
    @Override
    public boolean hasErrors() {
        int i;

        hasErrors |= dateTime.hasErrors() | eventType.hasErrors() | initiator.hasErrors();
        for (i = 0; i < descriptions.size(); i++) {
            hasErrors |= descriptions.get(i).hasErrors();
        }
        for (i = 0; i < errorDescs.size(); i++) {
            hasErrors |= errorDescs.get(i).hasErrors();
        }
        return hasErrors;
    }

    /**
     * Build a list of all of the errors generated by this Event
     * 
     * @param returnErrors if true return errors, otherwise return warnings
     * @param l list in which to place the errors/warnings
     */
    @Override
    public void getProblems(boolean returnErrors, List<VEOFailure> l) {
        int i;

        assert(l != null);
        
        super.getProblems(returnErrors, l);
        dateTime.getProblems(returnErrors, l);
        eventType.getProblems(returnErrors, l);
        initiator.getProblems(returnErrors, l);
        for (i = 0; i < descriptions.size(); i++) {
            descriptions.get(i).getProblems(returnErrors, l);
        }
        for (i = 0; i < errorDescs.size(); i++) {
            errorDescs.get(i).getProblems(returnErrors, l);
        }
    }

    /**
     * Has this Event any warnings?
     * @return true if errors have been detected
     */
    @Override
    public boolean hasWarnings() {
        int i;

        hasWarnings |= dateTime.hasWarnings() | eventType.hasWarnings() | initiator.hasWarnings();
        for (i = 0; i < descriptions.size(); i++) {
            hasWarnings |= descriptions.get(i).hasWarnings();
        }
        for (i = 0; i < errorDescs.size(); i++) {
            hasWarnings |= errorDescs.get(i).hasWarnings();
        }
        return hasWarnings;
    }

    /**
     * Produce a string representation of the Event
     *
     * @return The string representation
     */
    @Override
    public String toString() {
        StringBuffer sb;
        int i;

        sb = new StringBuffer();
        sb.append("Event\n   Date:");
        sb.append(dateTime);
        sb.append(" Event:");
        sb.append(eventType);
        sb.append(" Initiator:");
        sb.append(initiator);
        sb.append("\n");
        for (i = 0; i < descriptions.size(); i++) {
            sb.append("   Description:");
            sb.append(descriptions.get(i).toString());
            sb.append("\n");
        }
        for (i = 0; i < errorDescs.size(); i++) {
            sb.append("   Error:");
            sb.append(errorDescs.get(i).toString());
            sb.append("\n");
        }
        return sb.toString();
    }

    /**
     * Generate a HTML representation of the Event
     * @param verbose true if additional information is to be generated
     * @param writer where to write the output
     */
    public void genReport(boolean verbose, Writer w) {
        int i;

        assert (w != null);
        
        this.w = w;
        startDiv("Event", null);
        addLabel(eventType.getValue()+"Event");
        if (hasErrors || hasWarnings) {
            addTag("<ul>\n");
            listIssues();
            addTag("</ul>\n");
        }
        dateTime.genReport(verbose, w);
        initiator.genReport(verbose, w);
        for (i = 0; i < descriptions.size(); i++) {
            descriptions.get(i).genReport(verbose, w);
        }
        for (i = 0; i < errorDescs.size(); i++) {
            errorDescs.get(i).genReport(verbose, w);
        }
        endDiv();
    }
}
