/*
 * Copyright Public Record Office Victoria 2015
 * Licensed under the CC-BY license http://creativecommons.org/licenses/by/3.0/au/
 * Author Andrew Waugh
 * Version 1.0 February 2015
 */
package VEOAnalysis;

import VERSCommon.ResultSummary;
import VERSCommon.VEOError;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;

/**
 * This class represents the content of a VEOHistory.xml file.
 *
 * @author Andrew Waugh
 */
class RepnHistory extends RepnXML {
    String classname = "RepnHistory";
    RepnItem version; // version identifier of this VEOHistory.xml file
    ArrayList<RepnEvent> events;    // list of events associated with this history

    /**
     * Builds an internal representation of the VEOHistory.xml file, validating
     * it against the schema in VEOHistory.xsd.
     *
     * @param veoDir VEO directory containing the VEOHistory.xml file
     * @param schemaDir schemaDir directory containing the VEOHistory.xsd file
     * @param results the results summary to buil
     * @throws VEOError if a fatal error occurred
     */
    public RepnHistory(Path veoDir, Path schemaDir, ResultSummary results) throws VEOError {
        super("VEOHistory.xml", results);

        RepnEvent event;
        Path file, schema;
        int i;

        events = new ArrayList<>();
        version = new RepnItem(getId(), "XML version", results);

        // parse the VEOHistory.xml file against the VEOHistory scheme
        file = veoDir.resolve("VEOHistory.xml");
        schema = schemaDir.resolve("vers3-history.xsd");
        if (!parse(file, schema)) {
            return;
        }

        // extract the information from the DOM representation
        // the first element is VEOHistory, then comes VEOVersion
        gotoRootElement();
        checkElement("vers:VEOHistory");
        gotoNextElement();
        if (checkElement("vers:Version")) {
            version.setValue(getTextValue());
        }
        gotoNextElement();

        // step through the events
        i = 0;
        while (checkElement("vers:Event")) {
            gotoNextElement();
            i++;
            event = new RepnEvent(this, getId(), i, results);
            events.add(event);
        }
    }

    /**
     * Validate the data in the VEOHistory.xml file.
     *
     * @throws VEOError if a fatal error occurred
     */
    public final void validate() throws VEOError {
        int i;

        // can't validate if parse failed...
        if (!contentsAvailable()) {
            return;
        }

        // validate the version...
        if (!version.getValue().equals("3.0")) {
            version.addWarning(new VEOError(classname, "validate", 1, "VEOVersion has a value of '" + version.getValue() + "' instead of '3.0'"));
        }

        // validate the events...
        for (i = 0; i < events.size(); i++) {
            events.get(i).validate();
        }
    }

    /**
     * Free resources associated with this VEOHistory.xml file
     */
    @Override
    public void abandon() {
        int i;

        super.abandon();
        version.abandon();
        version = null;
        for (i = 0; i < events.size(); i++) {
            events.get(i).abandon();
        }
        events.clear();
        events = null;
    }

    /**
     * Has this VEOHistory.xml file has any errors?
     *
     * @return true if errors have been detected
     */
    @Override
    public boolean hasErrors() {
        int i;

        hasErrors |= version.hasErrors();
        for (i = 0; i < events.size(); i++) {
            hasErrors |= events.get(i).hasErrors();
        }
        return hasErrors;
    }

    /**
     * Build a list of all of the errors generated by this VEOHistory.xml file
     * 
     * @param returnErrors if true return errors, otherwise return warnings
     * @param l list in which to place the errors/warnings
     */
    @Override
    public void getProblems(boolean returnErrors, List<VEOError> l) {
        int i;

        super.getProblems(returnErrors, l);
        version.getProblems(returnErrors, l);
        for (i = 0; i < events.size(); i++) {
            events.get(i).getProblems(returnErrors, l);
        }
    }

    /**
     * Build a list of all of the errors generated by this VEOHistory.xml file
     *
     * @return String containing the concatenated error list
     */
    @Override
    public void getMesgs(boolean returnErrors, List<String> l) {
        int i;

        super.getMesgs(returnErrors, l);
        version.getMesgs(returnErrors, l);
        for (i = 0; i < events.size(); i++) {
            events.get(i).getMesgs(returnErrors, l);
        }
    }

    /**
     * Has this VEOHistory.xml file any warnings?
     *
     * @return true if errors have been detected
     */
    @Override
    public boolean hasWarnings() {
        int i;

        hasWarnings |= version.hasWarnings();
        for (i = 0; i < events.size(); i++) {
            hasWarnings |= events.get(i).hasWarnings();
        }
        return hasWarnings;
    }

    /**
     * Generate a String representation of the VEO History
     *
     * @return the String representation
     */
    @Override
    public String toString() {
        StringBuffer sb;
        int i;

        sb = new StringBuffer();
        sb.append(super.toString());
        if (contentsAvailable()) {
            sb.append(" VEOHistory - vers:Version: ");
            sb.append(version.toString());
            sb.append("\n");
            for (i = 0; i < events.size(); i++) {
                sb.append("  ");
                sb.append(events.get(i).toString());
            }
        } else {
            sb.append("VEOHistory: No valid content available as parse failed\n");
        }
        return sb.toString();
    }

    /**
     * Generate an XML representation of the VEOHistory file
     *
     * @param verbose true if additional information is to be generated
     * @param veoDir the directory in which to create the report
     * @param pVersion The version of VEOAnalysis
     * @param copyright The copyright string
     * @throws VEOError if a fatal error occurred
     */
    public void genReport(boolean verbose, Path veoDir, String pVersion, String copyright) throws VEOError {
        int i;

        createReport(veoDir, "Report-VEOHistory.html", "Report for 'VEOHistory.xml'", pVersion, copyright);
        startDiv("xml", null);
        addLabel("XML Document");
        if (hasErrors || hasWarnings) {
            addTag("<ul>\n");
            listIssues();
            addTag("</ul>\n");
        }
        if (contentsAvailable()) {
            version.genReport(verbose, w);
            for (i = 0; i < events.size(); i++) {
                events.get(i).genReport(verbose, w);
            }
        } else {
            addString(" VEOHistory.xml: No valid content available as parse failed\n");
        }
        endDiv();
        finishReport();
    }

    public static void main(String args[]) {
        RepnHistory rh;
        Path veoDir;
        Path schemaDir;

        veoDir = Paths.get("Test", "TestVEO.veo");
        schemaDir = Paths.get("Test", "Schemas");
        try {
            rh = new RepnHistory(veoDir, schemaDir, null);
            System.out.println(rh.toString());
        } catch (VEOError e) {
            System.out.println(e.getMessage());
        }
    }
}
